#!/bin/bash


#default user
user=($USER)

#read static variables
inst_root="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
source $inst_root/a_env_conf
source $inst_root/allas-lib

# local variable
object_name=""              #object to retrieve
print_help=0
os_project_name="$OS_PROJECT_NAME"
mode="swift"
tmp_dir="${tmp_root}/a_ecrypt_$$_tmp"
show_filelist=0
query=""
object_with_bucket=0
to_orig_dir=0
orig_dir=""
bucket=""
all=0
exe_dir=$(pwd)
start_time=$(date +%s)
encrypt=""
secret_key=""
all_keys=""
suffix=".c4gh"
replace=0
sdc=1
previous_bucket="x"

# read customer defaults
if [[ -e $HOME/.a_tools_conf ]]; then
   echo "Reading customer settings"  >&2
   source $HOME/.a_tools_conf
fi


#Process command line
while [[ $# -ge 1 ]]
do
  case "$1" in
             '--object' | '-o')
             # query file
                  object_name="$2"
                  shift
                  shift
                ;;
              '--s3cmd' )
                  mode=("s3cmd")
                  shift
                ;;

              '--lumi' )
                  mode=("lumi")
                  shift
                ;;
             '-b' | '--bucket' )
                  bucket="$2"
                  shift
                  shift
             ;;
             '-r' | '--replace')
                  replace=1
                  shift
             ;;
             '-s' | '--suffix')
                  suffix="$2"
                  shift
                  shift
             ;;
              '-a' | '--all')
                  all=1
                  shift
             ;;
              '--sdx' )
                  sdc=0
                  shift
	     ;;
	     '--sdx-to-sdc' )
                 secret_key=$(abspath "$2")
                 sdc=2
                 if [[ ! -e $secret_key ]];then
                    echo "Secret key $secret_key not found"
                    exit 1
                 fi
		             echo "Give password for $2 :"
                 read -s C4GH_PASSPHRASE
                 export C4GH_PASSPHRASE		 
		             shift
		             shift
             ;;
	      
              '-p' | '--pk' | '--public-key' )
                 # query file
                 public_key=$(abspath "$2")
                 sdc=0
                 if [[ -e $public_key ]];then
                    echo Public key: "$public_key"
                    all_keys=$(echo -en "$all_keys --recipient_pk $public_key ")
                    echo $all_keys
                 else
                    echo "Public key $public_key not found"
                    exit 1
                 fi
                 shift
                 shift
             ;;
             '-h' | '--help' )
                  print_help=(1)
                  shift
              ;;
             *)
                   if [[ $object_def != "" ]]; then
                      echo "unknown option: $1"  >&2
                      echo "Object name is: $object" >&2
                      exit 1
                   fi
                   object_def="$1"
                   shift                       # No more switches
               ;;
    esac
done



if [ $print_help -eq 1 ]; then
cat <<EOF
a-encrypt is used to apply SD Connect encryption to objects, that have already been uploaded to Allas.
The main purpose of this tool is to make a file, uploaded to the Allas service, compatible with the
SD Connect and SD Desktop services of CSC. Note that you must have SD Connect connection defined in 
order to use this command.

DEFAULT OPERATION: ENCRYPT AN OBJECT IN ALLAS

The basic syntax of the command is:

   a-encrypt object_name

The command above copies the object to the local computer where SD Connect encryption is applied
to the data. The encrypted data is then copied back to Allas into a new object. 
By default the encrypted object is located to the same bucket as the original object. 
Suffix: .c4gh is added to the object name.

You can user option --bucket the define that encrypted files will be stored to different location.
With option --all you can define that all the objects in a given location will be encrypted. 

Examples:

1. Make an encrypted copy of object my_data.csv that locate in bucket project-12345-data

   a-encrypt project-12345-data/my_data.csv

2. Make encrypted copies of all objects in bucket  project-12345-data to bucket  project-12345-sd

   a-encrypt project-12345-data --all --bucket project-12345-sd


CONVERTING OLD SD CONNECT FORMATTED OBJECTS INTO CURRENT SD CONNECT FORMAT

a-encrypt can be used to convert objects that have been encrypted with the old SD Connect format 
or with crypt4gh program into the current SD Connect format. In order to do this you must have
the corresponding crypt4gh secret key in the machine where where you execute this command. 
Note that during the conversion the data will be temporary store in a readable format in the machine
where the command is executed

The conversion process is enabled and the key file defined with option "--sdx-to-sdc your-secret-key"

For example:

    a-encrypt --sdx-to-sdc project_key.sec  project_12345_old_data/file_123.txt.c4gh

The command above will ask for the password of the defined secret key (project_key.sec) after which it will
convert object object onto current SD Connect format. As the object name file_123.txt.c4gh is already in user
prefix sdc_v2_ will be adder to the project name.

Alternatively you can define that the re-encrypted data will be stored to another folder. 
For example command:

  a-encrypt --sdx-to-sdc project_key.sec  --all project_12345_old_data  --bucket project_12345_converted_data

Would store all the objects in bucket project_12345_old_data in SD Connect encrypted format into
bucket project_12345_converted_data.

Note tha a-encrypt is not able to resolve what encryption method have been used to an encrypted file.
This means that the user must know, which files are encrypted with he old SD Connect methods and can thus be
converted into new SD Connect format.



SUMMARY OF A-ENCRYPT OPTIONS

Options:

-a, --all                        Process all the objects that include the given name (e.g. bucket name) in the beginning of
                                 object name. 

-r, --replace                    Remove the original un-encrypted object after encryption.

-b, --bucket <bucket_name>       Save the encrypted object to the given bucket instead of the original bucket.

--sdx                            Use old SD Connect encryption

--sdx-to-sdc  <secret-key>       Convert data that has been encrypted with SD Connect v1 to SD Connect v2 format
                                 The argument of this option defines the secret key that will be used to decrypt 
                                 SD Connect v1 data in the conversion process.

-p, --public_key <public key>    Use users own Public key for crypt4gh encryption. In this case data is not 
                                 compatible with SD Connect.

--s3cmd                          Use S3 protocol and s3cmd command for data retrieval instead of
                                 Swift protocol and rclone.

-s, --suffix <suffix>            Define your own suffix instead of the default suffix (.c4gh)



Related commands: a-put, a-find, a-info, a-delete

EOF

exit 0

fi

if [[ $object_def == "" ]]
then
  echo "Please give the object to retrieve:"  >&2
  read object_def
fi

project_label=$(echo ${os_project_name} |  sed -e s/"project_"/""/g)

#Check if connection works
if [[ $mode == "swift" ]]
then
  #here we check that rclone is available
  if [[ $(which rclone 2> /dev/null | wc -l ) -ne 1 ]];then
      echo ""  >&2
      echo "rclone is not available!" >&2
      echo "Please install rclone."  >&2
      exit 1
  fi
  #connection test
  test=$(rclone about ${storage_server}: 2> /dev/null | wc -l)
  #test=$(swift stat 2> /dev/null | grep -c "Account:")
  if [[ $test -lt 1 ]]
  then
    echo "No connection to Allas!"  >&2
    echo "Please try setting the connection again."  >&2
    echo "by running command:" >&2
    echo "" >&2
    echo "   source $allas_conf_path" >&2
    exit 1
  fi
fi

#Rclone through s3
if [[ $mode == "s3cmd" ]];then
   storage_server="s3allas"
fi

#Rclone through s3
if [[ $mode == "lumi" ]];then
   storage_server="lumi-o"
fi


#source /appl/opt/allas_conf
#input=("$1")



## object list creation depends on if --all
if [[ $all -eq 1 ]];then
  object_list=($(a-list $object_def 2> /dev/null))
else
  b_check=$(echo $object_def | grep -c "/")
  if [[ $b_check -eq 1 ]]; then
     object_list="$object_def"
  else
    echo "Definition $object_def did not define a single object"
    echo "Please use option --all if you want to encrypt all objects in a bucket"
    echo "or several objects, whose name starts with same string"
    exit 1
  fi
fi


#check that object list contains something
check_os=$(echo Â ${object_list[@]} | wc -c)
echo ${object_list[@]}
echo check_os: $check_os
if [[ $check_os -lt 2 ]]; then
     echo "Object name: $object_name not found in $storage_server." >&2
     echo "" >&2
     exit 1
fi




if [[ $sdc -eq 0 ]]; then
  ## Write CSC public key to a temporary file
  echo "Starting to process ${#object_list[@]} objects"
  echo "-----BEGIN CRYPT4GH PUBLIC KEY-----
  dmku3fKA/wrOpWntUTkkoQvknjZDisdmSwU4oFk/on0=
  -----END CRYPT4GH PUBLIC KEY-----" > .sdx_key_tmp_$$
fi


if [[ $sdc -gt 0 ]]; then
  make_temp_dir
  cd $tmp_dir
fi


for i in ${!object_list[@]}
do
  object_name="${object_list[$i]}"
  echo object_name $object_name
  source_bucket=$(echo $object_name | awk -F "/" '{print $1 }' )
  echo "source_bucket $source_bucket"
  object=$(echo $object_name | sed -e s/"$source_bucket\/"/""/ )
  echo "object: $object"
  if [[ $bucket != "" ]]; then
    target_bucket=$bucket
  else
    target_bucket="$source_bucket"
  fi


  if [[ $previous_bucket != $target_bucket ]]; then 
    #check of the bucket name is OK
    echo ""
    echo "Checking S3 validity of bucket $target_bucket"
  
    bucket_check=$(s3_name_check $target_bucket)
    while [[ $bucket_check != "OK" ]]
    do
        echo "Bucket name:  $target_bucket"
        echo "Is not compatibe with S3 bucket name rules"
        echo
	s3_name_check $target_bucket    
        echo ""
        echo "Do you want to change the target bucket name (y/n):"
        read ans
        if [[ $ans == "n" ]]; then
            bucket_check="OK"
        else
	    echo ""
	    echo "Give new bucket name:"
            read new_bname
            echo ""
	    echo "Do you want use bucket $new_bname for storing the encrypted data(y/n)?"
	    read ans
	    if [[ $ans == "y" || $ans == "yes" ]]; then
		target_bucket="$new_bname"
	    fi
	    bucket_check=$(s3_name_check $target_bucket)   
  	fi
    done	
  fi
  previous_bucket="$target_bucket"
  
  if [[ ${object_name:(-5):5} == "${suffix}" ]]; then
      target_object="${object}" 
  else      
      target_object="${object}${suffix}"
  fi
      
  echo ""
  echo "Making encrypted copy of ${source_bucket}/${object}"
  echo "to ${target_bucket}/$target_object"

  # no re-encryption for encrypted files excep in the conversion cases
  if [[ ${object_name:(-5):5} == "${suffix}" && $sdc -ne 2 ]]; then
    echo "$object_name is already encrypted."
    if [[ "${bucket}" != "" ]]; then
       rclone cat "${storage_server}:$object_name" | rclone rcat ${storage_server}:${target_bucket}/${object}
       check_os=$(rclone ls ${storage_server}:${target_bucket}/${object} 2> /dev/null | wc -l)
    else
       check_os=$(rclone ls ${storage_server}:${target_bucket}/${object} 2> /dev/null | wc -l)
    fi
  else
    
    #Case 0 ecryption using old SD Conenct format   
    if [[ $sdc -eq 0 ]]; then
       rclone cat -P "${storage_server}:$object_name" | crypt4gh encrypt --recipient_pk .sdx_key_tmp_$$ $all_keys | rclone rcat ${storage_server}:${target_bucket}/${target_object}
      check_os=$(rclone ls ${storage_server}:${target_bucket}/${target_object} 2> /dev/null | wc -l)
    fi

    # Default case. Data is coverted to SD Connect v2 format
    if [[ $sdc -gt 0 ]]; then
       echo " a-get --asis $object_name"
       a-get --asis "$object_name"
       exitcode=$?
       if [[ $exitcode -ne 0 ]]; then
          echo "Downloading $object_name Failed. Exiting"
          exit 1
       fi
       fname=$(echo "$object_name" | awk -F "/" '{print $NF}')
       echo "fname: $fname"

       #collcect pseudopath
       if [[ $sdc -eq 1 ]]; then
	   pseudopath=$(echo "$target_object" |sed -e s/"${fname}.c4gh$"/""/g )
       else
           pseudopath=$(echo "$target_object" |sed -e s/"${fname}$"/""/g )
       fi
	   
       echo "pseudopath: $pseudopath"

       
       #Decryption for SD Connecet V1 data
       if [[ $sdc -eq 2 ]]; then
	  f_decrypted=$(echo "$fname" |sed -e s/".c4gh$"/""/g)
	  crypt4gh decrypt --sk $secret_key < "$fname" > "$f_decrypted"
	  exitcode=$?
	  rm $fname
          if [[ $exitcode -ne 0 ]]; then
              echo "Decrypting $object_name Failed. Exiting"
              exit 1
          fi
	  fname="$f_decrypted"
          test_ob_exists=$(rclone ls ${storage_server}:${target_bucket}/${target_object} 2> /dev/null | wc -l )
	  if [[ $test_ob_exists -gt 0 ]]; then
	      if [[ $replace -eq 1 ]]; then
                rclone deletefile ${storage_server}:${target_bucket}/${target_object}
              else		  
	        mv $fname sdc_v2_$fname
                fname="sdc_v2_${fname}"
	        target_object="${pseudopath}${fname}.c4gh"
	      fi 
	  fi    
       fi
       echo "a-put --sdc $fname -b ${target_bucket}/${pseudopath}"
       a-put --sdc $fname -b ${target_bucket}/${pseudopath}
       rm $fname
       #echo "Debug: rclone:"
       #echo "rclone ls ${storage_server}:${target_bucket}/${target_object}"
       rclone ls ${storage_server}:${target_bucket}/${target_object}
       check_os=$(rclone ls ${storage_server}:${target_bucket}/${target_object} 2> /dev/null | wc -l)
    fi
    
  fi

  if [[ $check_os -ne 1 ]]; then
        echo "Error!"
        echo "Processing of object: $object_name Failed!"
        echo
        exit 1
  fi
  if [[ $replace -eq 1 ]]; then
     # Do not remove already encrypted objects
     if [[ ${object_name:(-5):5} == "${suffix}" ]]; then
        if [[ "${bucket}" != "" ]]; then
             echo "Removing original $object_name"
             rclone deletefile "${storage_server}:$object_name"
        fi
     else
       echo "Removing un-encrypted version of $object_name"
       rclone deletefile "${storage_server}:$object_name"
     fi
  fi
done


if [[ $sdc -gt 0 ]]; then
  rm -rf $tmp_dir
else
  rm -f .sdx_key_tmp_$$
fi

exit 0
